# 客户端和服务端

在这一章节，我们会深入学习怎样使用 Boost.Asio 建立非凡的客户端和服务端应用。你可以运行并测试它们，而且在理解之后，你可以把它们做为框架来构造自己的应用。

在接下来的例子中：

* 客户端使用一个用户名（无密码）登录到服务端。
* 所有的连接由客户端建立，当客户端请求时，服务端回应。
* 所有的请求和回复都以换行符结尾（'\n'）
* 对于 5 秒钟没有 ping 操作的客户端，服务端会自动断开其连接。

客户端可以发送如下请求：

* 获得所有已连接客户端的列表。
* 客户端可以 ping，当它 ping 时，服务端返回 ping ok 或者 ping client\_list\_changed（在接下来的例子中，客户端重新请求已连接的客户端列表）

为了更有趣一点，我们增加了一些难度：

* 每个客户端登录 6 个用户连接，比如 Johon, James, Lucy,Tracy, Frank 和 Abby。
* 每个客户端连接随机地 ping 服务端（随机 7 秒；这样的话，服务端会时不时关闭一个连接）

## 同步客户端/服务端

首先，我们会实现同步应用。你会发现它的代码很直接而且易读的。而且因为所有的网络调用都是阻塞的，所以它不需要独立的线程。

### 同步客户端

同步客户端会以你所期望的串行方式运行；连接到服务端，登录服务器，然后执行连接循环，比如休眠一下，发起一个请求，读取服务端返回，然后再休眠一会，然后一直循环下去……

![同步客户端](https://github.com/YaJunCui/notes/blob/master/images/boost_asio_sync_client.png?raw=true)

因为我们是同步的，所以我们让事情变得简单一点。首先，连接到服务器，然后再循环，如下：

```C++
ip::tcp::endpoint ep(ip::address::from_string("127.0.0.1"), 8001);

void run_client(const std::string & client_name) {
    talk_to_svr client(client_name);
    try {
        client.connect(ep);
        client.loop();
    } catch(boost::system::system_error & err) {
        std::cout << "client terminated " << std::endl;
    }
}
```

下面的代码片段展示了 talk\_to\_svr 类：

```C++
struct talk_to_svr {
    talk_to_svr(const std::string & username) : sock_(service),
        started_(true), username_(username) {}

    void connect(ip::tcp::endpoint ep) {
        sock_.connect(ep);
    }

    void loop() {
        write("login " + username_ + "\n");
        read_answer();
        while (started_) {
            write_request();
            read_answer();
            boost::this_thread::sleep(millisec(rand() % 7000));
        }
    }

    std::string username() const { return username_; }
    ...
private:
    ip::tcp::socket sock_;
    enum { max_msg = 1024 };
    int already_read_;
    char buff_[max_msg];
    bool started_;
    std::string username_;
};
```

在这个循环中，我们仅仅填充 1 个比特，做一个 ping 操作之后就进入睡眠状态，之后再读取服务端的返回。我们的睡眠是随机的（有时候超过 5 秒），这样服务端就有可能在某个时间点断开我们的连接：

```C++
void write_request() {
    write("ping\n");
}

void read_answer() {
    already_read_ = 0;
    read(sock_, buffer(buff_), boost::bind(&talk_to_svr::read_complete, this, _1, _2));
    process_msg();
}

void process_msg() {
    std::string msg(buff_, already_read_);
    if (msg.find("login ") == 0)
        on_login();
    else if (msg.find("ping") == 0)
        on_ping(msg);
    else if (msg.find("clients ") == 0)
        on_clients(msg);
    else
        std::cerr << "invalid msg " << msg << std::endl;
}
```

对于读取结果，我们使用在之前章节就有说到的 read\_complete 来保证我们能读到换行符（'\n'）。这段逻辑在 process\_msg() 中，在这里我们读取服务端的返回，然后分发到正确的方法去处理：

```C++
void on_login() { do_ask_clients(); }

void on_ping(const std::string & msg) {
    std::istringstream in(msg);
    std::string answer;
    in >> answer;
    if (answer == "client_list_changed")
        do_ask_clients();
}

void on_clients(const std::string & msg) {
    std::string clients = msg.substr(8);
    std::cout << username_ << ", new client list:" << clients;
}

void do_ask_clients() {
    write("ask_clients\n");
    read_answer();
}

void write(const std::string & msg) {
    sock_.write_some(buffer(msg));
}

size_t read_complete(const boost::system::error_code & err, size_t bytes) {
    // ... 和之前一样
}
```

在读取服务端对我们 ping 操作的返回时，如果得到的消息是 client\_list\_changed，我们就需要重新请求客户端列表。

### 同步服务端

同步服务端也是相当简单的。它只需要两个线程，一个负责接收新的客户端连接，另外一个负责处理已经存在的客户端请求。它不能使用单线程，因为等待新的客户端连接是一个阻塞操作，所以我们需要另外一个线程来处理已经存在的客户端请求。

![同步服务端](https://github.com/YaJunCui/notes/blob/master/images/boost_asio_sync_server.png?raw=true)

正常来说服务端都比客户端要难实现。一方面，它要管理所有已经连接的客户端。因为我们是同步的，所以我们需要至少两个线程，一个负责接受新的客户端连接（因为 accept()是阻塞的）而另一个负责回复已经存在的客户端。

```C++
void accept_thread() {
    ip::tcp::acceptor acceptor(service,ip::tcp::endpoint(ip::tcp::v4(), 8001));
    while (true) {
        client_ptr new_(new talk_to_client);
        acceptor.accept(new_->sock());
        boost::recursive_mutex::scoped_lock lk(cs);
        clients.push_back(new_);
    }
}

void handle_clients_thread() {
    while (true) {
        boost::this_thread::sleep( millisec(1));
        boost::recursive_mutex::scoped_lock lk(cs);
        for(array::iterator b = clients.begin(), e = clients.end(); b!= e; ++b)
            (*b)->answer_to_client();
        // 删除已经超时的客户端
        clients.erase(std::remove_if(clients.begin(), clients.end(), boost::bind(&talk_to_client::timed_out,_1)), clients.end());
    }
}
int main(int argc, char* argv[]) {
    boost::thread_group threads;
    threads.create_thread(accept_thread);
    threads.create_thread(handle_clients_thread);
    threads.join_all();
}
```a