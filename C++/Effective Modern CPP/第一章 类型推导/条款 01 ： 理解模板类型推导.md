# 条款01：理解模板类型推导 

一些用户对复杂的系统会忽略它怎么工作，怎么设计的，但是很高兴去知道它完成的一些事。通过这样的方式，C++ 中的模板类型的推导取得了巨大的成功。数以万计的程序员曾传过参数给模板函数，并得到了满意的结果。尽管很多程序员很难给出比朦胧的描述更多的东西，比如那些被推导的函数是怎么使用类型来推导的。

如果你也是其中的一员，我这有好消息和坏消息给你。好消息是模板类型的推导是现代 C++ 最令人惊叹特性之一（auto）的基础。如果你熟悉 C++98 的模板类型推导，那么你也会熟悉 C++11 怎么使用auto来做推导类型。而坏消息是，与模板类型推导规则应用到模板上相比，模板类型推导规则应用在 auto 上，有时候可能会缺乏直观的认识。由于这个原因，我们很有必要完全理解模板类型推导的各个方面，因为 auto 是建立在这个基础上的。这个条款包含了你想知道的东西。

如果你愿意浏览少许伪代码，我们可以把函数模板看成这样子：

```C++
template <typename T>
void f(ParamType param);
```

对于函数的调用看起来是这样的：

```C++
 f(expr);                   //使用 expr 作为实参调用 f
```

在整个编译期间，编译器用 expr 来推导两个类型：一个是 T，另一个是
ParamType。这两个类型通常是不一样的，因为 ParamType 常常包含一些修饰符（比如 const 或引用的限定等）。比方说，如果一个模板声明成这样：

```C++
template <typename T>
void f(const T& param);                    //ParamType 是 const T&
```

然后我们这样使用它：

```C++
int x = 0;
f(x);                                      //使用 int 作为实参调用 f
```

T 被推导成 int，但是 ParamType 被推导成 const int&。

很自然会觉得 T 类型就是传入函数的实参类型，也就是T 是 expr 的类型。在上面的例子中，x 是 int，T 被推导成 int，但是它不总是这样工作的。对 T 类型的推导，不仅仅取决于 expr ，同时也取决于 ParamType。这里有三种情况：

1. ParamType 是指针或引用，但不是一个universal引用（universal引用在条款24中描述，现在，你要知道的就是，他们存在，并且左引用和右引用是不相同的）。
2. ParamType 是 universal 引用。
3. ParamType 不是指针也不是引用。

因此，我们有三种类型的推导情况需要分析。每一个将建立在下面这个模板的基础上，并如此调用：

```C++
template<typename T>
void f(ParamType param);

f(expr);                         //根据 expr 来推导 T 或者 ParamType 的类型
```

## 情况1：参数是指针或引用，但不是一个universal引用

这种情况是最简单的情况，类型推导将这么工作：

1. 如果 expr 的类型是引用，忽略引用的部分。
2. 然后用 expr 的类型模式匹配 ParamType 来决定T。

比方说，我们的模板如下所示：

```C++
template<typename T>
void f(T& param);
```

并且我们有这些变量声明：

```C++
int x = 27;
const int cx = x;
const int& rx = x;
```