# 理解特殊成员函数的生成规则

C++ 的官方说法中，特殊成员函数是 C++ 愿意去主动生成的。C++98 有 4 个这样的函数：默认构造函数，析构函数，拷贝构造函数，拷贝操作符。当然，这里有些细则。这些函数只在需要的时候产生，也就是，在类中如果一些代码没有清楚地声明它们就使用了它们。一个默认构造函数只有在类中没有声明任何构造函数的情况下才会被生成出来（当你的目的是要求这个类的构造函数必须提供参数时，这防止编译器为你的类生成一个默认构造函数）。特殊成员函数被隐式生成为 public 和 inline，并且它们是 nonvirtual，除非是在派生类中的析构函数，并且这个派生类继承自带 virtual 析构函数的基类。在这种情况下，派生类中，编译器生成的析构函数也是 virtual。

但是你已经知道这些事情了。是的，是的，这些都是古老的历史了：两河流域，商朝，FORTRAN，C++98。但是时间变了，同时 C++ 中特殊成员函数的生成规则也改变了。意识到新规则的产生是很重要的，因为没有什么事能和“知道什么时候编译器会悄悄地把成员函数插入到你的类中”一样能作为高效 C++ 编程的核心了。

在 C++11 中，特殊成员函数“俱乐部”有两个新成员：move 构造函数和move 拷贝操作符。这里给出它们的函数签名：

```C++
class Widget{
public:
    ...
    Widget(Widget&& rhs);               //move构造函数

    Widget& operator=(Widget&& rhs);    //move assignment operator
    ...
};
```

控制它们的生成和行为的规则和它们的“copying 兄弟”很像。move 操作只有在被需要的时候生成，并且如果它们被生成出来，它们对类中的 non-static 成员变量执行“memberwise move”（“以成员为单位逐个 move”）。这意味着 move 构造函数，用参数 rhs 中的相应成员移动构造（move-construct）每个 non-static 成员变量，并且 move operator= 移动赋值（move-assign）每个 non-static 成员变量。move 构造函数同样“移动构造”基类的部分（如果存在的话），并且 move operator= 也移动赋值它的基类部分。

现在，当我提及 move 操作（移动构造或移动赋值）一个成员变量或基类时，不能保证 move 会真正发生。“memberwise move”事实上更像一个请求，因为那些不是 move-enabled（能移动的）类型（也就是，不提供 move 操作的类型，比如，大多数 C++98 遗留下来的类）将通过copy操作来“move”。每个 memberwise “move”的关键都是 std::move 的应用，首先 move 来自一个对象（std::move 的参数），然后通过函数重载解析来决定执行 move 或 copy，最后产生一个结果（move来的或copy来的）。条款23 包含了这个过程的细节。在这个条款中，只需要简单地记住“memberwise move”是这么运作的：当成员函数和基类支持 move 操作时，就使用 move，如果不支持 move 操作，就使用 copy。

与 copy 操作一样，如果你自己声明了 move 操作，编译器就不会帮你生成了。但是，它们被生成的具体条件和 copy 操作有一点不一样。

两个 copy 操作是独立的：声明一个不会阻止编译器生成另外一个。所以如果你声明了一个拷贝构造函数，但是没有声明拷贝 operator=，然后你写的代码中要用到拷贝赋值，编译器将帮你生成一个拷贝 operator=。相似的，如果你声明了一个拷贝operator=，但是没有声明拷贝构造函数，然后你的代码需要 copy 构造，编译器将帮你生成一个拷贝构造函数。这在 C++98 中是正确的，在 C++11 还是正确的。

两个 move 操作不是独立的：如果你声明了任何一个，那就阻止了编译器生成另外一个。也就是说，基本原理就是，如果你为你的类声明了一个 move 构造函数，那么你就表明你的 move 构造函数和编译器生成的不同，它不是通过默认的 memberwise move 来实现的。并且如果 memberwise move 构造函数不对的话，那么 memberwise move 赋值函数也应该不对。所以声明一个 move 构造函数会阻止一个 move operator= 被自动生成，声明一个 move operator= 函数会阻止一个 move 构造函数被自动生成。

另外，如果任何类显式地声明了一个 copy 操作，move 操作就不会被自动生成。理由是，声明一个 copy 操作（构造函数或复制操作符）表明，用正常的方法（memberwise copy）来拷贝对象对于这个类来说是不合适的。编译器认为，如果对于 copy 操作来说 memberwise copy 不合适，那么对于 move 操作来说 memberwise move 很有可能也是不合适的。

反过来也是这样。声明一个 move 操作会使得编译器让 copy 操作不可用（通过 delete（见 条款11）可以使得 copy 操作不可用。）总之，如果 memberwise move 不是 move 一个对象最合适的方法，就没有理由期望 memberwise copy 是 copy 这个对象的合适方法。这听起来可能会破坏 C++98 的代码，因为比起 C++98，在 C++11 中让 copy 操作有效的限制条件要更多，但是情况不是这样的。C++98 的代码没有 move 操作，因为在 C++98 中没有和“moving”一个对象一样的事情。遗留的类唯一能拥有一个 user-declared（用户自己声明的）move 操作的方式是它们被添加到 C++11 中，并且利用 move 语义来修改这个类，这样这个类才必须按照 C++11 的规则来生成特殊成员函数（也就是抑制 copy 操作的生成）。

也许你已经听过被称为“三法则”（“the Rule of Three”）的准则了。三法则说明了如果你声明了任何一个拷贝构造函数，赋值操作符或析构函数，那么你应该声明所有的这三个函数。它产生于一个观察（自定义 copy 操作的需求几乎都来自一种类，这种类需要对一些资源进行管理），并且大部分暗示着：（1）在一个copy操作中做的任何资源管理，在另一个 copy 操作中很可能也需要做同样的管理。（2）类的析构函数也需要参与资源管理（通常是释放资源）。需要被管理的经典资源就是内存了，并且这也是为什么所有管理内存的标准库类（比如，执行动态内存管理的 STL 容器）都被称作“the big three”：两个 copy 操作和一个析构函数。

三法则的一个结论是：类中出现一个 user-declared 析构函数表示简单的 memberwise copy 可能不太适合 copy 操作。这反过来就建议：如果一个类声明了一个析构函数，copy 操作可能不应该被自动生成，因为它们可能将作出一些不正确的事。在 C++98 被采用的时候，这个原因的重要性没有被发现，所以在 C++98 中，user-declared 析构函数的存在不会影响编译器生成 copy 操作的意愿。这种情况在 C++11 中还是存在的，但是这只是因为，如果限制限制 copy 操作的生成，将会破坏太多的遗留代码。

但是，三法则背后的原因还是有效的，并且，结合之前的观察，copy 操作的声明阻止隐式 move 操作的生成，这促使了一个事实，C++11 在一个类中有一个 user-declared 的析构函数时，就不会自动生成 move 操作。

所以只在下面这三个事情为真的时候才为类生成 move 操作（当需要的时候）：

* 没有 copy 操作在类中被声明。
* 没有 move 操作在类中被声明。
* 没有析构函数在类中被声明。

在某些情况下，相似的规则可能延伸到 copy 操作中去，因为当一个类中声明了 copy 操作或者一个构造函数时，C++11 不赞成自动生成 copy 操作。这意味着如果你的类中，已经声明了析构函数或者其中一个 copy 操作，但是你依赖于编译器帮你生成另外的 copy 操作，那么你应该“升级”一下这些类来消除依赖。如果编译器生成的函数提供的行为是正确的（也就是，如果 memberwise copy 就是你想要的），你的工作就很简单了，因为 C++11 的“=default”让你能显式地声明：

```C++
class Widget {
public:
    ...
    ~Widget();                          //user-declared析构函数
    ...
    Widget(const Widget&) = default;    //默认的拷贝构造函数的行为OK的话

    Widget& operator=(const Widegt&) = default; //默认的行为OK的话
    ...
};
```

这种方法在多态基类中常常是有用的，也就是，定义派生类对象需要被调用的接口的类。多态基类通常拥有 virtual 析构函数，因为如果它们没有，一些操作（比如，通过指向派生类对象的基类指针进行 delete 操作或基类引用进行 typeid 操作）会产生未定义或错误的结果。除非这个类继承了一个已经是 virtual 的析构函数，而唯一让析构函数成为 virtual 的办法就是显示声明它。常常，默认实现是对的，“=default”就是很好的方法来表达它。但是，一个 user-declared 析构函数抑制了 move 操作的产生，所以如果 move 的能力是被支持的，“=default”就找到第二个应用的地方了。声明一个 move 操作会让 copy 操作失效，所以如果 copy 的能力也是需要的，新一轮的“=deafult”能做这样的工作:

```C++
class Base{
public:
    virtual ~Base() = default;              //让析构函数成为virtual

    Base(Base&&) = default;                 //支持move
    Base& operator=(Base&&) = default;

    Base(const Base&) = default;            //支持copy
    Base& operator=(const Base&) = default;
    ...
};
```

事实上，即使你有一个类，编译器愿意为这个类生成 copy 和 move 操作，并且生成的函数的行为是你想要的，你可能还是要接受上面的策略，自己声明它们并且使用“= default”作为定义。这样需要做更多的工作，但是它使得你的意图看起来更清晰，并且它能帮你
避开一些很微妙的错误。举个例子，假设你有一个类表示一个字符串表格，也就是一个数据结构，它允许用一个整形 ID 来快速查阅字符串的值：

```C++
class StringTable{
public:
    StringTable() {}
    ...                     //插入，删除，查找函数等等，但是没有copy/move/析构函数

private:
    std::map<int, std::string> values;
};
```

假设这个类没有声明 copy 操作，move 操作，以及析构函数，这样编译器就会自动生成这些函数如果它们被使用了。这样非常方便。

但是假设过了一段时间后，我们觉得记录默认构造函数以及析构函数会很有用，并且添加这样的功能也很简单：

```C++
class StringTable{
public:
    StringTable()
    { makeLogEntry("Creating StringTable object");}     //后加的

    ~StringTable()
    { makeLogEntry("Destroying StringTable object");}   //也是后加的
    ...                                                 //其他的函数

private:
    std::map<int, std::string> values;
};
```

这看起来很合理，但是声明一个析构函数有一个重大的潜在副作用：它阻止 move 操作被生成。但是 copy 操作的生成不受影响。因此代码很可能会编译通过，执行，并且通过功能测试。这包括了 move 功能的测试，因为即使这个类中不再有 move 的能力，但是请求 move，它是能通过编译并且执行的。这样的请求在本条款的前面已经说明过了，它会导致 copy 的调用。这意味着代码中“move” StringTable 对象实际上是 copy 它们，也就是，copy std::map<int, std::string> 对象。然后呢，copy 一个 std::map<int, std::string> 对象很可能比 move 它会慢好几个数量级。因此，简单地为类增加一个析构函数就会引进一个重大的性能问题！如果之前把 copy 和 move 操作用“=default”显式地定义了，那么问题就不会出现了。

现在，已经忍受了我无止境的啰嗦，在 C++11 中 copy 操作和 move 操作生成的控制规则之后，你可能会想知道什么时候我才会把注意力放在另外两个特殊成员函数上，默认构造函数和析构函数。现在就是时候了，但是只有这句话，因为这些成员函数几乎没有改变：C++11 中的规则几乎和 C++98 中的规则一样。

C++11 对特殊成员函数的控制规则是这样的：

* **默认构造函数**：和 C++98 中的规则一样。只在类中没有 user-declared 的构造函数时生成。
* **析构函数**：本质上和 C++98 的规则一样;唯一的不同就是析构函数默认声明为 noexcept（见 条款14）。和 C++98 一样，只有基类的析构函数是 virtual 时，析构函数才会是 virtual。
* **拷贝构造函数**：和 C++98 一样的运行期行为：memberwise 拷贝构造 non-static 成员变量。只在类中没有 user-declared 拷贝构造函数时被生成。如果类中声明了一个 move 操作，它就会被删除。在有 user-declared 赋值操作符或析构函数时，这个函数能被生成，但是这种生成方法是被弃用的。
* **赋值操作符**：和 C++98 一样的运行期行为：memberwise 拷贝赋值 non-static 成员变量。只在类中没有 user-declared 赋值操作符时被生成。如果类中声明了一个 move 操作，它就会被删除。在有 user-declared 拷贝构造函数或析构函数时，这个函数能被生成，但是这种生成方法是被弃用的。
* **move 构造函数和 move 赋值操作符**：每个都对 non-static 成员变量执行 memberwise move。只有类中没有 user-declared 拷贝操作，move 操作或析构函数时被生成。

注意，关于成员函数模板的存在，这里没有规则规定它会阻止编译器生成特殊成员函数。这意味着如果 Widget 看起来像这样：

```C++
class Widget{
public:
    ...
    template<typename T>
    Widget(const T& rhs);               //构造自任何类型

    template<typename T>
    Widget& operator=(const T& rhs);    //赋值自任何类型
    ...
};
```

即使这些 template 能实例化出拷贝构造函数和赋值操作符的函数签名（就是T是Widget的情况），编译器仍然会为 Widget 生成 copy 和 move 操作（假设以前抑制它们生成的条件满足了）。在所有的可能性中，这将作为一个勉强值得承认的边缘情况让你感到困惑，但是这是有原因的，我之后会提及它的。条款26 说明了这是有很重要的原因的。

## 请记住

* 特殊成员函数是那些编译器可能自己帮我们生成的函数：默认构造函数，析构函数，copy　操作，move　操作。
* 只有在类中没有显式声明的　move　操作，copy　操作和析构函数时，move　操作才被自动生成。
* 只有在类中没有显式声明的拷贝构造函数的时候，拷贝构造函数才被自动生成。只要存在　move　操作的声明，拷贝构造函数就会被删除。当类中没有显式声明赋值操作符时，赋值操作符才会被生成。并且，如果 move 操作被声明，它也会被删除。在有显式声明的构造函数中，copy　操作能被生成，但是这种生成方法是被弃用的。
* 成员函数模板永远不会抑制特殊成员函数的生成。
